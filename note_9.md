##  Формирование архитектуры. 

Данный разбор буду излагать по кластерам, на которые разбиты сущности. 
### Ядро системы
1. Схема создания объектов: 
	- объекты АТД `Dispatcher` и `State` создаются единожды при старте программы, время их жизни совпадает со временем работы игры.
	- объект АТД `Event` (событие) создается только в рамках и в контексте  `Dispatcher`-а.
	- Логика `Dispatcher`  разбивается  на несколько отдельных блоков, для которых изначально создавался АТД `Rule` (исключенный на этапе фильтрации сущностей).  По сути это функция с определенным прототипом `f(S): S -> (S, E)`, которая принимает на вход состояние и возвращает новое состояние + событие (набор событий), которое преобразует это состояние.  
	- существует механизм регистрации обработчика состояния в `Dispatcher`.
	- события (Event) применяются диспетчером после отработки каждого правила.
2. Схема обработки событий: 
	- все события, созданные в процессе  в игры  работы события добавляются в очередь, которая обрабатывается `Dispatcher`-ом.
	- события обрабатываются в хронологическом порядке.
	- время игры дискретное, пошаговое; границы шага определяются периодом между двумя последовательными пользовательскими вводами (данное правило можно пересмотреть и кастомизировать).
	- `Dispatcher` предоставляет возможность подписаться на изменения состояния State. Подписчик не может генерировать события. Примером подписчика является компонент отображения на экран (`Renderer`), либо отдельный компонент подсчета статистики. 
3. Увязка с фреймворками: для ядра достаточно стандартных библиотек python. 
4. Тесты для типовых сценариев: тестовый обработчик, который анализирует состояние и генерирует событие;  тестовое событие, которое изменяет состоение; тестовый наблюдатель, который фиксирует изменение состояния. При прохождении цикла создания-обработки событий сравнивается  последовательность выполнения вызовов создания/обрабтки/анализа событий. 


### Элементы игрового поля
Сюда входят АТД `Grid`, `Cell`, `Element`. 
1. Схема создания объектов: `Grid`, `Cell` создается во время создания игрового поля при старте очередного раунда игры. `Element` создается в рамках события генерации нового элемента. 
2. Схема обработки событий: События, связанные  с созданием/уничтожением элемента создаются внутри правил `Rule`, связанных  c функционированием игрового поля. 
3. Увязка с фреймворками: для реализации внутренней логики работы достаточно стандартных компонентов. 
4. Тесты для типовых сценариев: тестовый обработчик  `Rule` для событий создания, уничтожения и движения объектов по игровому полю. Тесты для движения элементов при уничтожении, тесты для генерации элементов.


### Renderer
1. Схема создания объектов: Renderer создается при старте игры. 
2. Схема обработки событий: Renderer является подписчиком `Dispatcher` и наблюдает за событиями в игре. При изменении элементов, которые заданы как видимые, `Renderer` меняет отображение. 
3. Увязка с фреймворками: для отображения достаточно стандартных библиотек, либо можно использовать PyGame. В любом  случае будет необходимо создать отдельные переходные АТД, которые будут отвечать за корректное отображение игрового поля на экране. 
4. Тесты для типовых сценариев: будут включать в себя  отдельные тесты для АТД - переходников. Также сюда будут включаться тесты вычисления положения элементов на экране. 

### Вспомогательные классы
Сюда входит `FigureTree` (изначально именовался FigureGraph) , который используется для выявления фигур на игровом поле. 
1. Схема создания объектов: создается каждый раз при анализе конфигурации игрового поля.  
2. Схема обработки событий: в рамках общей схемы , описанной в ядре. 
3. Увязка с фреймворками: возможно использование библиотеки pygraph. Дополнительная увязка не требуется. 
4. Тесты для типовых сценариев: тестированию подлежит алгоритм нахождения фигур в конфигурации поля. 
